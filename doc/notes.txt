unit-unit collision detection and response: who does what?
	1) engine detects collision, engine handles response?
	2) engine detects collision, module handles response?
	3) module detects collision, engine handles response?
	4) module detects collision, module handles response?

	should detection be sphere-based only? register units in
	grid-cells based on radius + speed instead of only radius?
	should responses be "soft" (only overriding steering input)
	or "hard" (teleporting units to non-colliding positions)?

current module handles path-finding and path-following for individual
objects and/or groups: only input to module consists of definitions of
groups (which units are part of them) and destination positions, only
output (provided via call-outs) consists of the new "wanted" position
and direction for each unit so that engine can apply these as steering
and throttle "inputs" ==> engine controls actual unit physics / dynamics

for CC, module probably needs direct control over unit positions, etc.
(especially since unit movement might no longer obey physics constraints)

engine has corner-heightmap, center-heightmap, and center-slopemap
(slopemap is half the resolution of the heightmap), slopes are not
parameterized by direction!



Continuum Crowds
	"use a potential function to guide pedestrians (!) to their goal"
	"use discomfort fields to handle geographical preferences"

	"grid discretization scheme is tailored for the difficult case
	of fine grid resolutions relative to the size of the people" ?

	HYPOTHESIS 1
		each person is trying to reach a geographic goal G \subset R^2
		(GOAL IS A SET OF POINTS! GOAL SELECTION IS EXOGENEOUS TO MODEL)

	HYPOTHESIS 2
		people move at maximum speed possible given environmental
		conditions (slopes, boundaries, congestion, etc.), expressed
		by speed-field <F>

			v = F(X, T) * n_T

		where X is 2D location xy, T is the direction angle, n_T is
		transpose([cos T, sin T]) (unit-length direction vector in
		Carthesian coordinates), and v is speed vector

		/////////////////////////////////////////////////////////////
		NOTE: engine does not work with 2D angles, each object only
		has a 3D (!) direction vector in Carthesian coordinates (n_T)
		/////////////////////////////////////////////////////////////


	HYPOTHESIS 3
		there exists a discomfort-field <D> such that people prefer
		being at 2D position X rather than at Y if D(Y) > D(X) and
		all other factors are equal (ALSO EXOGENEOUS TO MODEL)

		"dynamic discomfort can be used to enhance collision avoidance"

	"in general, people choose the minimum-distance path to their destination"
	"this preference is tempered by a desire to avoid congestion and exposure
	to areas of high discomfort ... classic trade-off between energy and time
	minimization"

	summary: people choose paths so as to minimize linear combination of
	three terms: 1) length of path, 2) amount of time to destination, 3)
	discomfort experienced per unit-time along the path

	HYPOTHESIS 4
		PI is set of all paths from position X to *some point in goal*
		assuming that speed-field <F>, discomfort-field <D>, and goal G
		are fixed, a person at X will pick path P \in PI that minimizes
		the path-cost

			alpha * INTEGRAL_{P} (1) ds +   (PATH-LENGTH)
			beta  * INTEGRAL_{P} (1) dt +   (PATH-TIME)
			gamma * INTEGRAL_{P} (D) dt     (PATH-DISCOMFORT)

		ds: integral taken wrt. path length
		dt: integral taken wrt. time

		because distance (ds) is speed (F) * time (dt) and hence
		ds / F = dt, we can rewrite to

			alpha * INTEGRAL_{P} (1    ) ds
			beta  * INTEGRAL_{P} (1 / F) ds
			gamma * INTEGRAL_{P} (D / F) ds

		which can again be simplified to give the path-cost

			INTEGRAL_{P} (C) ds   [4]

		where

			C = (alpha * F  +  beta  +  gamma * D) / F

		is the unit-cost field

	COMPUTING THE OPTIMAL PATH
		suppose we have a function phi: R^2 --> R^2 that, for every 2D
		position xy, returns the cost of the optimal path to the goal

		moving along the OPPOSITE gradient of this function decreases
		the cost of the path most rapidly, therefore we can define phi
		as

			| DELTA phi(X) |  =  C   [5]

		where the unit-cost field is evaluated in the direction of the
		gradient, DELTA phi

		at any given location X, every person moves in the direction
		opposite to the gradient at X, scaled by the speed at X:

                             DELTA phi(X)
			v = -F(X, T) * ----------------   [6]
                           | DELTA phi(X) |


		"Suppose a GROUP of people all share an identical speed field,
		discomfort, and goal. This is often the case in crowds when a
		number of people are trying to get to the same location at
		approximately the same speed. In this case, we need to calculate
		the potential function for the GROUP only once, deriving optimal
		paths for ALL group members simultaneously. In reality, of course,
		people move at different speeds, have varied perceptions of discomfort,
		and seek different goals. Therefore, we DIVIDE THE CROWD INTO A SET
		OF GROUPS, each with different characteristics. At each timestep we
		construct a potential function phi FOR EACH GROUP and then move the
		people in that group according to [6]. Since each group affects the
		speed f and discomfort g across all other groups, the entire crowd
		motion is coupled.

		"Solving Equation (5) is the slowest aspect of simulation. Thus,
		we prefer to have as few groups as possible."

	SPEED
		"speed is density-dependent variable: at low densities, speed is
		dominated by terrain (constant on flat surfaces, changing with
		slope), at higher densities speed becomes dominated by movement
		of nearby people"

		introduce the crowd-density-field rho
		convert each person i to individual density field rho_i
		rho_i peaks at location of person i, falls off radially
		exact shape of each rho_i is irrelevant
		crowd-density field is sum of all individual density fields:
			rho = SUM_{i} rho_i    [7A]

		AVERAGE-VELOCITY-FIELD scales person i's DENSITY by i's velocity:
			V_avg = (SUM_{i} rho_i * v_i) / rho    [7B]

		both SUMmations are taken across ALL people in ALL groups!

		density affects speed as follows:
			[1] IF rho <= rho_min (for some rho_min), F is equal to the TOPOLOGICAL speed
			F_T, assuming terrain is bounded to minimum- and maximum-slopes S_min and S_max:

				F_T(X, T) = F_max + K * (F_min - F_max)    [8]

			where K = ( (DELTA H(X) * n_T) - S_min) / (S_max - S_min) and
			(DELTA H(X) * n_T) is slope of height-field H in direction T

			////////////////////////////////////////////////////////////////
			NOTE: engine represents slopes as y-component of terrain normal,
			it does not maintain either S_min or S_max and there also is no
			notion of "directional slope"
			NOTE: everything in the paper assumes a 2D model, but now slopes
			are introduced?
			////////////////////////////////////////////////////////////////


			[2] IF rho >= rho_max (for some rho_max), F is equal to the FLOW
			speed:

				F_F(X, T) = V_avg(X + r * n_T) * n_T    [9]

			ie. the average velocity V_avg evaluated at a distance <r> from
			2D position X, which causes people to look at V_avg for the area
			*into which* they are trying to move


			[3] IF rho_min < rho < rho_max, linearly interpolate between F_T
			(topological speed) and F_F (flow speed):

				F(X, T) = F_T(X, T) + K * (F_F(X, T) - F_T(X, T))    [10]

			where K = (rho(X + r * n_T) - rho_min) / (rho_max - rho_min)
			note that density is also evaluated at an offset (r * N_t) so
			agents are not self-obstructed by their own contribution to
			the density field

	FUTURE PREDICTION
		"Individuals in our crowd simulator account for the future by path
		planning through a constantly updated static view of the environment.
		That is, the model takes into account moving obstacles, but not that
		the obstacles are moving. Often this simplification is justiﬁed: real
		pedestrians avoid those walking in the opposite direction and intelligently
		plan around areas of high congestion. In this model however, when two
		people cross perpendicularly, they fail to anticipate one another. We
		address this by adding a small amount of discomfort in front of each
		person, causing others to avoid this region. SPECIFICALLY, we advance
		each person’s position by their velocity for several timesteps depositing
		to the discomfort ﬁeld an amount proportional to the density that would
		be calculated were the person there."

	IMPLEMENTATION
		for each time-step
			convert agent-crowd to density field rho

			for each group
				construct unit-cost-field C
				construct potential-field phi and gradient DELTA phi
				update locations of agents in group

			enforce minimum-distance separation between agent [HACK]

		space is discretized into regular grid, each grid-cell stores several quantities

		* all physical fields are 2D arrays
		* scalar fields are defined at the center of each cell, 1 float   (D, phi, rho, H)
		* average velocity V_avg is ALSO stored at cell centers, 2 floats (in 2D)
		* fields indexed by position and direction are defined at cell edges, 4 floats
		* F, C, DELTA H, DELTA phi, V) are ALSO defined at edges
		* DELTA H and DELTA phi are shared between neighbors, F and C are "bidirectional"

		agents are "splatted" onto density grid (discretization of rho) by some conversion
		function; this conversion function must ensure that 1) density grid is continuous
		wrt. agent locations (so their movement does not cause sharp discontinuities) and
		that 2) each agent contributes no LESS than rho_i? to its own grid cell and no MORE
		than rho_i to any neighboring cell (so no agent can be affected by its own density
		contribution)

		for 1): can use bilinear or Gaussian splatting, etc.
		for 2):
			for each agent <a>, find the center of the closest cell whose 2D-coordinates
			are both less than <a>'s, compute relative coordinates between A and this cell
			center, then add <a>'s density to four cells ABCD as follows

				rho_A = min(1 - dx, 1 - dy)^lambda
				rho_B = min(    dx, 1 - dy)^lambda
				rho_C = min(    dx,     dy)^lambda
				rho_D = min(1 - dx,     dy)^lambda

			where lambda is the exponent determining speed of density falloff



	function UpdatePotentialField(IN goalPos, IN costField, OUT potField):
		potField[goalPos] = 0

		for each cellPos != goalPos:
			potField[cellPos] = +INF

		knownCellPositions = {goalPos}
		unknownCellPositions = {cellPos for each cellPos != goalPos}
		candidateCellPositions = neighbors(knownCellPositions)

		while (not all cell potentials updated):
			minPotential = +INF

			for each cellPos in candidateCellPositions:
				// calculate FDA to newCellPotential according to equation 11
				minPotentialCellPosDirX = argmin(
					potField[ cellPos + <0, -1> ] + costField[ cellPos + <0, -1> ],
					potField[ cellPos + <0,  1> ] + costField[ cellPos + <0,  1> ]
				)
				minPotentialCellPosDirY = argmin(
					potField[ cellPos + <-1,  0> ] + costField[ cellPos + <-1,  0> ],
					potField[ cellPos + < 1,  0> ] + costField[ cellPos + < 1,  0> ]
				)

				// M is variable for newCellPotential value at cellPos
				// Px = potField[minPotentialCellPosDirX]
				// Py = potField[minPotentialCellPosDirY]
				// Cx = costField[ cellPos --> minPotentialCellPosDirX ]
				// Cy = costField[ cellPos --> minPotentialCellPosDirY ]
				//
				// a/b + c/d = ad/bd + cb/bd = (ad+cb)/bd      (!)
				//
				// (M - Px)^2   (M - Py)^2
				// ---------- + ---------- = 1   ==>
				//    Cx^2        Cy^2
				//
				// M^2 - 2Px*M + Px^2   M^2 - 2Py*M + Py^2
				// ------------------ + ------------------ = 1   ==>
				//        Cx^2                 Cy^2
				//
				// (M^2 - 2Px*M + Px^2) * Cy^2   (M^2 - 2Py*M + Py^2) * Cx^2
				// --------------------------- + --------------------------- = 1   ==>
				//         Cx^2 * Cy^2                   Cx^2 * Cy^2
				//
				// ((M^2 - 2Px*M + Px^2) * Cy^2) + ((M^2 - 2Py*M + Py^2) * Cx^2)
				// ------------------------------------------------------------- = 1   ==>
				//                          Cx^2 * Cy^2
				//
				// ((M^2 - 2Px*M + Px^2) * Cy^2) +
				// ((M^2 - 2Py*M + Py^2) * Cx^2) = Cx^2 * Cy^2   ==>
				//
				// 2*M^2 - (2Px + 2Py)*M + (Px^2 + Py^2) = Cx^2 * Cy^2   ==>
				//
				// 2*M^2 - (2Px + 2Py)*M + (Px^2 + Py^2) - (Cx^2 * Cy^2) = 0
				//
				// a = 2
				// b = -(2Px + 2Py)
				// c = (Px^2 + Py^2) - (Cx^2 * Cy^2)
				// D = b*b - 4*a*c
				//
				// M = (-b +/- sqrt(D)) / 2*a

				newCellPotential = max(M_solution_1, M_solution_2)
				potField[cellPos] = newCellPotential
				deltaCellPotential = <
					newCellPotential - potField[minPotentialCellPosDirX],
					newCellPotential - potField[minPotentialCellPosDirY]
				>


				if potField[cellPos] < minPotential:
					minPotential = potField[cellPos]
					minPotentialCellPos = cellPos

			knownCellPositions = knownCellPositions + {minPotentialCellPos}
			candidateCellPositions = candidateCellPositions + neighbors(minPotentialCellPos)




	method described in paper for governing speed on slopes does not
	consider per-unittype maxSlope restrictions; slope is calculated
	"on the fly" by sampling heightfield in two? places along direction
	a unit is moving

	each group has its own unique potential-/speed-/discomfort-field?
	(for heterogeneous groups, this means most restrictive constraints
	on movement must be obeyed ==> group must move at speed of slowest
	unit, etc)

	what use is the velocity-field v? according to 4.3, this is the
	speed-field multiplied by normalized gradient of potential-field,
	but we do not need to compute it explicitly at all to update unit
	positions via equation [6] ? ==> not true, we need to (bilinearly)
	interpolate vector values at corners


	cost-field (C) needs
		speed-field (f)
		discomfort-field (g)

	speed-field (f) needs
		density-field (rho)
		average-velocity-field (v-bar)
		terrain-slope (delta-H)

	potential-field (phi) needs
		cost-field (C)

	average-velocity-field (v-bar) needs
		density-field (rho)

	velocity-field (v) needs
		speed-field (f)
		potential-field gradient (delta-phi)
